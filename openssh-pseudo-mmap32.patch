--- ./monitor_mm.c.org	Mon Jul  1 15:17:07 2002
+++ ./monitor_mm.c	Mon Jul  1 15:16:55 2002
@@ -29,6 +29,7 @@
 #ifdef HAVE_SYS_MMAN_H
 #include <sys/mman.h>
 #endif
+#include <sys/shm.h>
 
 #include "ssh.h"
 #include "xmalloc.h"
@@ -85,8 +86,41 @@
 	mm->mmalloc = mmalloc;
 
 #if  defined(HAVE_MMAP) && defined(MAP_ANON)
+	mm->shm_not_mmap = 0;
+	
 	address = mmap(NULL, size, PROT_WRITE|PROT_READ, MAP_ANON|MAP_SHARED,
 	    -1, 0);
+
+	if (address == MAP_FAILED) {
+		int shmid;
+
+		shmid = shmget(IPC_PRIVATE, size, IPC_CREAT|S_IRUSR|S_IWUSR);
+		if (shmid != -1) {
+			address = shmat(shmid, NULL, 0);
+			shmctl(shmid, IPC_RMID, NULL);
+			if (address != MAP_FAILED)
+				mm->shm_not_mmap = 1;
+		}
+	}
+
+	if (address == MAP_FAILED) {
+		char tmpname[sizeof(MM_SWAP_TEMPLATE)] = MM_SWAP_TEMPLATE;
+		int tmpfd;
+		int save_errno;
+		
+		tmpfd = mkstemp(tmpname);
+		if (tmpfd == -1)
+			fatal("mkstemp(\"%s\"): %s",
+					MM_SWAP_TEMPLATE, strerror(errno));
+		unlink(tmpname);
+		ftruncate(tmpfd, size);
+		address = mmap(NULL, size, PROT_WRITE|PROT_READ, MAP_SHARED,
+				tmpfd, 0);
+		save_errno = errno;
+		close(tmpfd);
+		errno = save_errno;
+	}
+	
 	if (address == MAP_FAILED)
 		fatal("mmap(%lu)", (u_long)size);
 #else
@@ -131,6 +165,10 @@
 	mm_freelist(mm->mmalloc, &mm->rb_allocated);
 
 #ifdef HAVE_MMAP
+	if (mm->shm_not_mmap) {
+		if (shmdt(mm->address) == -1)
+			fatal("shmdt(%p): %s", mm->address, strerror(errno));
+	} else
 	if (munmap(mm->address, mm->size) == -1)
 		fatal("munmap(%p, %lu)", mm->address, (u_long)mm->size);
 #else
--- ./monitor_mm.h.org	Tue Mar 26 04:42:21 2002
+++ ./monitor_mm.h	Mon Jul  1 15:18:26 2002
@@ -40,6 +40,7 @@
 	struct mmtree rb_allocated;
 	void *address;
 	size_t size;
+	int shm_not_mmap;
 
 	struct mm_master *mmalloc;	/* Used to completely share */
 
@@ -53,6 +54,8 @@
 
 #define MM_ADDRESS_END(x)	(void *)((u_char *)(x)->address + (x)->size)
 
+#define MM_SWAP_TEMPLATE	"/var/run/sshd.mm.XXXXXXXX"
+
 struct mm_master *mm_create(struct mm_master *, size_t);
 void mm_destroy(struct mm_master *);
 
